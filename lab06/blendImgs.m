function [stitchedImage] = blendImgs(warpedImage, img1, leftTopUnwarpX, leftTopUnwarpY, blendType, warpImgWeight)

%> Code Description: 
%     Given the first image and the warped image, blend the stitched image 
%     such that using the user-defined blending algorithm the resultant 
%     stitched image is seamless. Use in conjunction with the function 
%     getNewImg.m
%
%> Inputs: 
%     warpedImage:    The warp image. This is generated by the function 
%                     getNewImg.m
%     img1:           The first original image (the unwarped image)
%     leftTopUnwarpX: The left top x coordinate of the unwarped image.
%                     This is generated by the function getNewImg.m
%     leftTopUnwarpY: The left top y coordinate of the unwarped image.
%                     This is generated by the function getNewImg.m
%     blendType:      A string argument specifying the use of the blend
%                     algorithm. 
%                     'weightBlend': blending by weighting channel values
%                     'maxValue':    blending by the maximal channel value 
%                     'linearBlend': blending by linear interpolation of 
%                                    channel values 
%                     'AvgBlend':    blending by averaging channel values
%     warpImgWeight:  The interpolation weights after warping the image.
%                     This is generated by the function getNewImg.m
%
%> Outputs:
%     stitchedImage:  The final stitched image ready for visualization.
%                     
%
%> (c) LEMS, Brown University
%> Chiang-Heng Chien (chiang-heng_chien@brown.edu)
%> Oct. 5th, 2020

    %> change notation
    x = leftTopUnwarpX;
    y = leftTopUnwarpY;
    
    %> fetch the channel of the original image to specify the image type
    [~, ~, channel] = size(img1);
    if (channel > 1)
        imgType = 'color';
    else
        imgType = 'gray';
    end

    %> Construct a mask for the warped imgs
    %  First investigate whether there is nan value in the two imgs
    warpedImage(isnan(warpedImage)) = 0;
    %> Second, mask is defined by those non-zero intensities in the imgs 
    %  (pixs except the balck background area)
    switch imgType
        case 'color'
            maskA = (warpedImage(:,:,1)>0 | warpedImage(:,:,2)>0 | warpedImage(:,:,3)>0);
        case 'gray'
            maskA = (warpedImage > 0);
    end

    %> Define a new img that stitch unwarpped img to a proper size canvas
    %  with black in background
    stitchedImage = zeros(size(warpedImage));
    stitchedImage(y:y+size(img1,1)-1, x: x+size(img1,2)-1,:) = img1;
    
    %> Construct a weight image for unwarp img
    [unwarpRows, unwarpCols, ~] = size(img1);
    imgTopDist = repmat(reshape(1:unwarpRows, unwarpRows, 1), [1, unwarpCols]);
    imgLeftDist = repmat(reshape(1:unwarpCols, 1, unwarpCols), [unwarpRows, 1]);
    imgRightDist = repmat(reshape(unwarpCols:-1:1, 1, unwarpCols), [unwarpRows, 1]);
    imgBottomDist = repmat(reshape(unwarpRows:-1:1, unwarpRows, 1), [1, unwarpCols]);
    imgDist_LR = min(imgLeftDist, imgRightDist);
    imgDist_TB = min(imgTopDist, imgBottomDist);
    unwarpImgWeight = min(imgDist_LR, imgDist_TB);
    newImgWeight = zeros(size(warpedImage, 1), size(warpedImage, 2));
    newImgWeight(y:y+size(img1,1)-1, x: x+size(img1,2)-1) = unwarpImgWeight;

    switch blendType
        case 'maxValue'
            %> Select the maximal value
            switch imgType
                case 'color'
                    stitchedImage(:,:,1) = max(double(warpedImage(:,:,1)), double(stitchedImage(:,:,1)));
                    stitchedImage(:,:,2) = max(double(warpedImage(:,:,2)), double(stitchedImage(:,:,2)));
                    stitchedImage(:,:,3) = max(double(warpedImage(:,:,3)), double(stitchedImage(:,:,3)));
                case 'gray'
                    stitchedImage = max(double(warpedImage), double(stitchedImage));
            end

        case 'linearBlend'
            %> Construct a mask for the unwarped imgs
            switch imgType
                case 'color'
                    mask = (stitchedImage(:,:,1)>0 | stitchedImage(:,:,2)>0 | stitchedImage(:,:,3)>0);
                case 'gray'
                    mask = (stitchedImage > 0);
            end

            %> Determine the union of the two imgs where non-background region is given to the mask
            mask = and(maskA, mask);

            %> Compute the overlapped region between these two imgs
            [~, col] = find(mask);
            left = min(col);
            right = max(col);
            mask = ones(size(mask));

            %> Use linspace to create dissolution on the overlapped region for the warp img
            if (x < 2)
                mask(:,left:right) = repmat(linspace(0, 1, (right-left+1)), size(mask,1), 1);
            else
                mask(:,left:right) = repmat(linspace(1, 0, (right-left+1)), size(mask,1), 1);
            end

            %> filter each channel of the warped img according to the mask
            switch imgType
                case 'color'
                    warpedImage(:,:,1) = double(warpedImage(:,:,1)).*mask;
                    warpedImage(:,:,2) = double(warpedImage(:,:,2)).*mask;
                    warpedImage(:,:,3) = double(warpedImage(:,:,3)).*mask;
                case 'gray'
                    warpedImage = double(warpedImage).*mask;
            end

            %> Use linspace to create dissolution on the overlapped region for the unwarped imgs
            if (x < 2)
                mask(:,left:right) = repmat(linspace(1, 0, right-left+1),size(mask,1), 1);
            else
                mask(:,left:right) = repmat(linspace(0, 1, right-left+1),size(mask,1), 1);
            end

            %> filter each channel of the unwarped img according to the mask and add
            %  with the warped img directly
            switch imgType
                case 'color'
                    stitchedImage(:,:,1) = double(stitchedImage(:,:,1)).*mask;
                    stitchedImage(:,:,2) = double(stitchedImage(:,:,2)).*mask;
                    stitchedImage(:,:,3) = double(stitchedImage(:,:,3)).*mask;

                    stitchedImage(:,:,1) = double(warpedImage(:,:,1)) + double(stitchedImage(:,:,1));
                    stitchedImage(:,:,2) = double(warpedImage(:,:,2)) + double(stitchedImage(:,:,2));
                    stitchedImage(:,:,3) = double(warpedImage(:,:,3)) + double(stitchedImage(:,:,3));
                case 'gray'
                    stitchedImage = double(stitchedImage).*mask;
                    stitchedImage = double(warpedImage) + double(stitchedImage);
            end
        
        case 'AvgBlend'
            %> Construct a mask for the unwarped imgs
            switch imgType
                case 'color'
                    mask = (stitchedImage(:,:,1)>0 | stitchedImage(:,:,2)>0 | stitchedImage(:,:,3)>0);
                case 'gray'
                    mask = (stitchedImage > 0);
            end

            %> Determine the union of the two imgs where non-background region is given to the mask
            mask = and(maskA, mask);

            %> Compute the overlapped region between these two imgs
            [row, col] = find(mask);
            left = min(col);
            right = max(col);
            top = min(row);
            bottom = max(row);
            mask = mask * 0.5;
            mask_tmp = ones(size(mask));
            mask = mask_tmp - mask;

            %> filter each channel of the warped img according to the mask
            switch imgType
                case 'color'
                    warpedImage(:,:,1) = double(warpedImage(:,:,1)).*mask;
                    warpedImage(:,:,2) = double(warpedImage(:,:,2)).*mask;
                    warpedImage(:,:,3) = double(warpedImage(:,:,3)).*mask;
                case 'gray'
                    warpedImage = double(warpedImage).*double(mask);
            end

            %> filter each channel of the unwarped img according to the mask and add
            %  with the warped img directly
            switch imgType
                case 'color'
                    stitchedImage(:,:,1) = double(stitchedImage(:,:,1)).*mask;
                    stitchedImage(:,:,2) = double(stitchedImage(:,:,2)).*mask;
                    stitchedImage(:,:,3) = double(stitchedImage(:,:,3)).*mask;

                    stitchedImage(:,:,1) = double(warpedImage(:,:,1)) + double(stitchedImage(:,:,1));
                    stitchedImage(:,:,2) = double(warpedImage(:,:,2)) + double(stitchedImage(:,:,2));
                    stitchedImage(:,:,3) = double(warpedImage(:,:,3)) + double(stitchedImage(:,:,3));
                case 'gray'
                    stitchedImage = double(stitchedImage).*double(mask);
                    stitchedImage = double(warpedImage) + double(stitchedImage);
            end
            
        case 'weightBlend'
            %> Reference: Thévenaz, Philippe, and Michael Unser. 
            %             "User‐friendly semiautomated assembly of accurate 
            %             image mosaics in microscopy." Microscopy research
            %             and technique 70, no. 2 (2007): 135-146.
            
            %> Construct a mask for the unwarped imgs to extract valid area
            switch imgType
                case 'color'
                    mask = (stitchedImage(:,:,1)>0 | stitchedImage(:,:,2)>0 | stitchedImage(:,:,3)>0);
                case 'gray'
                    mask = (stitchedImage > 0);
            end

            %> Determine the union of the two imgs where non-background 
            %  region is given to the mask
            mask = and(maskA, mask);
            
            %> Multiply the mask over two imgs
            newImgWeight = double(newImgWeight).*mask;
            warpImgWeight = double(warpImgWeight).*mask;
            addWeight = newImgWeight + warpImgWeight;
            mask_f0 = double(newImgWeight) ./ double(addWeight);
            mask_f1 = double(warpImgWeight) ./ double(addWeight);
            mask_f0(isnan(mask_f0)) = 0;
            mask_f1(isnan(mask_f1)) = 0;
            mask_rev = ones(size(mask));
            mask_rev = double(mask_rev - mask);
            
            mask_f0 = double(mask_f0) + double(mask_rev);
            mask_f1 = double(mask_f1) + double(mask_rev);
            
            %> Filter each channel of the unwarped img according to the 
            %  mask and add with the warped img directly
            switch imgType
                case 'color'
                    warpedImage(:,:,1) = double(warpedImage(:,:,1)).*double(mask_f1);
                    warpedImage(:,:,2) = double(warpedImage(:,:,2)).*double(mask_f1);
                    warpedImage(:,:,3) = double(warpedImage(:,:,3)).*double(mask_f1);
                    
                    stitchedImage(:,:,1) = double(stitchedImage(:,:,1)).*double(mask_f0);
                    stitchedImage(:,:,2) = double(stitchedImage(:,:,2)).*double(mask_f0);
                    stitchedImage(:,:,3) = double(stitchedImage(:,:,3)).*double(mask_f0);

                    stitchedImage(:,:,1) = double(warpedImage(:,:,1)) + double(stitchedImage(:,:,1));
                    stitchedImage(:,:,2) = double(warpedImage(:,:,2)) + double(stitchedImage(:,:,2));
                    stitchedImage(:,:,3) = double(warpedImage(:,:,3)) + double(stitchedImage(:,:,3));
                case 'gray'
                    warpedImage = double(warpedImage).*double(mask_f1);
                    stitchedImage = double(stitchedImage).*double(mask_f0);
                    stitchedImage = double(warpedImage) + double(stitchedImage);
            end
    end
end